<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>树的直径</title>
    <link href="/2020/10/03/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2020/10/03/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p>给定一棵树，树中包含 $n$ 个结点（编号$1\sim n$）和 $n−1$ 条无向边，每条边都有一个权值。</p><p>现在请你找到树中的一条最长路径。</p><p>换句话说，要找到一条路径，使得使得路径两端的点的距离最远。</p><p>注意：路径中可以只包含一个点。</p><p><strong>输入格式</strong></p><p>第一行包含整数 $n$。</p><p>接下来 $n−1$ 行，每行包含三个整数 $a_i,b_i,c_i$，表示点 $a_i$ 和 $b_i$ 之间存在一条权值为 $c_i$ 的边。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示树的最长路径的长度。</p><p><strong>数据范围</strong></p><p>$1≤n≤10000$,<br>$1≤a_i,b_i≤n$,<br>$−10^5≤ci≤10^5$</p><p><strong>输入样例：</strong></p><pre><code class="hljs basic"><span class="hljs-number">6</span><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">6</span><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-symbol">6 </span><span class="hljs-number">3</span> <span class="hljs-number">9</span><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">8</span><span class="hljs-symbol">6 </span><span class="hljs-number">1</span> <span class="hljs-number">7</span></code></pre><p><strong>输出样例：</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">22</span></code></pre><pre><code class="hljs c++"><span class="hljs-comment">// 树的直径：每个点取经过它的最长和次长距离，相加后最大的就是树的直径</span><span class="hljs-comment">// 这里采用的是树形dp做法</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10010</span>, M = N * <span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> h[N], e[M], w[M], ne[M], idx;<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;&#125;<span class="hljs-comment">// 这里还传了父节点，可以保证只会往下搜索</span><span class="hljs-comment">// 返回值：以u为根节点往下搜索的最长距离</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> father)</span> </span>&#123;    <span class="hljs-keyword">int</span> dist = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前点往下走的最长距离</span>    <span class="hljs-keyword">int</span> d1 = <span class="hljs-number">0</span>, d2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// d1:最长距离，d2:次长距离</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;        <span class="hljs-keyword">int</span> j = e[i];        <span class="hljs-keyword">if</span> (j == father) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 保证只往下搜索</span>                <span class="hljs-keyword">int</span> d = dfs(j, u) + w[i];        dist = max(dist, d);                <span class="hljs-comment">// 这里之所以不用dist来更新，而是用d，是因为dist到达的终点不一定是子节点j到达的终点</span>        <span class="hljs-comment">// d1和d2求的是经过u的距离</span>        <span class="hljs-keyword">if</span> (d &gt; d1) d2 = d1, d1 = d;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d &gt; d2) d2 = d;    &#125;        ans = max(ans, d1 + d2);        <span class="hljs-keyword">return</span> dist;    &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++) &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        add(a, b, c), add(b, a, c);    &#125;        <span class="hljs-comment">// 树是联通的，所以任取一点开始搜索</span>    dfs(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>树形dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2020/09/25/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2020/09/25/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="组合数（求-C-a-b-模上p的值）"><a href="#组合数（求-C-a-b-模上p的值）" class="headerlink" title="组合数（求$C_a^b$模上p的值）"></a>组合数（求$C_a^b$模上p的值）</h2><p>根据数据范围来选择</p><p>$C_a^b$ 看a和b的范围</p><h3 id="a-b-le-2000"><a href="#a-b-le-2000" class="headerlink" title="a, b $\le$ 2000"></a>a, b $\le$ 2000</h3><p>$C_a^b = C_{a-1}^b + C_{a-1}^{b-1}$ 可以<strong>通过递推来计算</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> c[N][N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++)            <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    init();        <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">while</span> (n --) &#123;        <span class="hljs-keyword">int</span> a, b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c[a][b]);    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="a-b-le-10-5"><a href="#a-b-le-10-5" class="headerlink" title="a, b $\le$  $10^{5}$"></a>a, b $\le$  $10^{5}$</h3><p>预处理$\frac{a!}{(a-b)!b!}$中的阶乘</p><p>除数的取余需要用到逆元，<strong>预处理</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> fact[N], infact[N]; <span class="hljs-comment">// infact表示逆元</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> mod)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % mod;    <span class="hljs-keyword">while</span> (k) &#123;        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % mod;        a = (LL)a * a % mod;        k &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i ++ ) &#123;        fact[i] = (LL)fact[i - <span class="hljs-number">1</span>] * i % mod;        infact[i] = (LL)infact[i - <span class="hljs-number">1</span>] * qmi(i, mod - <span class="hljs-number">2</span>, mod) % mod;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    init();        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">while</span> (n --) &#123;        <span class="hljs-keyword">int</span> a, b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (LL)fact[a] * infact[b] % mod * infact[a - b] % mod);    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="a-b-le-10-18"><a href="#a-b-le-10-18" class="headerlink" title="a, b $\le$ $10^{18}$"></a>a, b $\le$ $10^{18}$</h3><p>mod上p的值，p是质数</p><p>数据量大，使用卢卡斯定理：$C_a^b\equiv C_{a, mod, p}^{b,mod,p} * C_{a/p}^{b/p},(mod,p)$</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-keyword">int</span> n, p;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p;    <span class="hljs-keyword">while</span> (k) &#123;        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = a; i &lt;= b; i ++, j --) &#123;        res = (LL)res * j % p;        res = (LL)res * qmi(i, p - <span class="hljs-number">2</span>) % p;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(LL a, LL b)</span> </span>&#123;    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> C(a, b);    <span class="hljs-keyword">return</span> (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">while</span> (n --) &#123;        LL a, b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;p);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, lucas(a, b));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>答案不取模时使用高精度</p><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>$C_{2n}^n - C_{2n}^{n-1} = C_{2n}^n / (n + 1)$</p><p>给定n个0和n个1，它们将按照某种顺序排成长度为2n的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中0的个数都不少于1的个数的序列有多少个。</p><p>输出的答案对10^9^+7取模。</p><p><strong>输出格式</strong></p><p>共一行，包含整数n。</p><p><strong>输出格式</strong></p><p>共一行，包含一个整数，表示答案。</p><p><strong>数据范围</strong></p><p>1≤n≤10^5^</p><p><strong>输入样例：</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">3</span></code></pre><p><strong>输出样例：</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">5</span></code></pre><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>, N = <span class="hljs-number">200010</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p;    <span class="hljs-keyword">while</span> (k) &#123;        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n; i &gt; n; i --) res = (LL)res * i % mod;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) res = (LL)res * qmi(i, mod - <span class="hljs-number">2</span>, mod) % mod;        res = (LL)res * qmi(n + <span class="hljs-number">1</span>, mod - <span class="hljs-number">2</span>, mod) % mod;        <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>组合计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
