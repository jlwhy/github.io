<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>糖果</title>
    <link href="/2020/10/06/%E7%B3%96%E6%9E%9C/"/>
    <url>/2020/10/06/%E7%B3%96%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>糖果店的老板一共有 $M$ 种口味的糖果出售。</p><p>为了方便描述，我们将 $M$ 种口味编号 $1∼M$。</p><p>小明希望能品尝到所有口味的糖果。</p><p>遗憾的是老板并不单独出售糖果，而是 KK 颗一包整包出售。</p><p>幸好糖果包装上注明了其中 $K$ 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。</p><p>给定 $N$ 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 $N,M,K$。</p><p>接下来 $N$ 行每行 $K$ 这整数 $T_1,T_2,···,_TK$，代表一包糖果的口味。</p><p><strong>输出格式</strong></p><p>一个整数表示答案。</p><p>如果小明无法品尝所有口味，输出 $−1$。</p><p><strong>数据范围</strong></p><p>$1≤N≤100$,<br>$1≤M,K≤20$,<br>$1≤T_i≤M$</p><p><strong>输入样例：</strong></p><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span></code></pre><p><strong>输出样例：</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">2</span></code></pre><p><strong>这是一道重复覆盖问题</strong></p><p>1.迭代加深</p><p>2.找出选择最少的列</p><p>3.h()函数，至少要选多少行(估价函数)，可行性剪枝</p><p>代码中的<code>(1 &lt;&lt; m) - 1 - state</code> ，这可以用到位运算优化，方便使用lowbit函数：</p><p>如果<code>state</code>值是5，二进制表示<code>101</code>，<code>(1 &lt;&lt; m) - 1</code>是 <code>111</code>，那么相减之后就是 <code>010</code>，此时相减后的结果中的<code>1</code>就表示还没选的那一列，而求出二进制中的每一位<code>1</code>，我们可以用到<code>lowbit</code>函数，为了方便直接找到是第几位，还可以预处理<code>log2</code>的各个值</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>, M = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<span class="hljs-keyword">int</span> n, m, k;<span class="hljs-keyword">int</span> Log2[M];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; col[N]; <span class="hljs-comment">// 存储的是这一行有哪些列可以选到</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">return</span> x &amp; -x;&#125;<span class="hljs-comment">// 最少还需要选几行，估价函数，用来剪枝</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span> </span>&#123;    <span class="hljs-keyword">int</span> res= <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (<span class="hljs-number">1</span> &lt;&lt; m) - <span class="hljs-number">1</span> - state; i; i -= lowbit(i)) &#123;        <span class="hljs-keyword">int</span> c = Log2[lowbit(i)];        <span class="hljs-comment">// 把所有能选到这一列的行全部算进去</span>        res ++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> row : col[c]) i &amp;= ~row;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> depth, <span class="hljs-keyword">int</span> state)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!depth || h(state) &gt; depth) <span class="hljs-keyword">return</span> state == ((<span class="hljs-number">1</span> &lt;&lt; m) - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 找到选择性最少的一列</span>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (<span class="hljs-number">1</span> &lt;&lt; m) - <span class="hljs-number">1</span> - state; i; i -= lowbit(i)) &#123;        <span class="hljs-comment">// c:当前还没选的那一列</span>        <span class="hljs-keyword">int</span> c = Log2[lowbit(i)];        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">-1</span> || col[t].size() &gt; col[c].size())            t = c;    &#125;        <span class="hljs-comment">// 枚举选哪一行</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> row : col[t])        <span class="hljs-keyword">if</span> (dfs(depth - <span class="hljs-number">1</span>, state | row)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++) Log2[<span class="hljs-number">1</span> &lt;&lt; i] = i;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;        <span class="hljs-keyword">int</span> state = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j ++) &#123;            <span class="hljs-keyword">int</span> c;            <span class="hljs-built_in">cin</span> &gt;&gt; c;            state |= (<span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-number">1</span>)); <span class="hljs-comment">// 把每包糖果用state这个数来表示，方便之后的二进制计算</span>        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)            <span class="hljs-keyword">if</span> (state &gt;&gt; j &amp; <span class="hljs-number">1</span>) col[j].push_back(state);    &#125;        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (depth &lt;= m &amp;&amp; !dfs(depth, <span class="hljs-number">0</span>)) depth ++;        <span class="hljs-keyword">if</span> (depth &gt; m) depth = <span class="hljs-number">-1</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; depth &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dfs</tag>
      
      <tag>IDA*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>X的因子链</title>
    <link href="/2020/10/04/X%E7%9A%84%E5%9B%A0%E5%AD%90%E9%93%BE/"/>
    <url>/2020/10/04/X%E7%9A%84%E5%9B%A0%E5%AD%90%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="X的因子链"><a href="#X的因子链" class="headerlink" title="X的因子链"></a>X的因子链</h1><p>输入正整数 $X$，求 $X$ 的大于 1 的因子组成的满足任意前一项都能整除后一项的严格递增序列的最大长度，以及满足最大长度的序列的个数。</p><p><strong>输入格式</strong></p><p>输入包含多组数据，每组数据占一行，包含一个正整数表示 X。</p><p><strong>输出格式</strong></p><p>对于每组数据，输出序列的最大长度以及满足最大长度的序列的个数。</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><p>$1≤X≤2^{20}$</p><p><strong>输入样例：</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-number">10</span><span class="hljs-number">100</span></code></pre><p><strong>输出样例：</strong></p><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><span class="hljs-symbol">4 </span><span class="hljs-number">6</span></code></pre><p>每个数就相当于在前一个的基础上再乘一个因子。<br>我们选择用质因子来乘，因为如果是非质因子，那么它还可以分解，序列就会变长<br>基于以上的分析，我们考虑算数基本定理</p><p>$N=P_1^{c_1}*P_2^{c_2}*P_3^{c_3}…*P_k^{c_k}$</p><p>其中P都是质因子</p><p>根据分析，可以构造以下的序列：</p><p>假设有2个$P_1$，2个$P_2$，1个$P_3$，那么因子可以有以下排列：</p><p>​        $P_1 \quad \quad P_2 \quad \quad \quad P_1 \quad \quad \quad \quad P_2 \quad \quad \quad \quad \quad P_3$        构成的序列为</p><p>​        $P_1 \quad P_1*P_2 \quad P_1^{2} * P_2 \quad \quad P_1^{2}*P_2^{2} \quad \quad P_1^{2}*P_2^{2}*P_3$</p><p>第一问也就是5个数，第二问序列的个数就是求这5个数有多少种不同的排列，即多重集的排列数问题</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-keyword">int</span> n;LL p[N], c[N], cnt;LL f[N];<span class="hljs-comment">// 预处理阶乘</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">31</span>; i ++) f[i] = f[i - <span class="hljs-number">1</span>] * i;&#125;<span class="hljs-comment">// 算数基本定理</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n); i ++) &#123;        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;            p[++ cnt] = i, c[cnt] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i, c[cnt] ++;        &#125;    &#125;        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) p[++ cnt] = n, c[cnt] = <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    init();        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) &#123;        divide(n);                    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计每个质因子的个数</span>        LL temp = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i ++) count += c[i], temp *= f[c[i]];                LL ans1 = count, ans2 = f[count];                <span class="hljs-comment">/*</span><span class="hljs-comment">         ans2 / temp: 多重集的排列数问题</span><span class="hljs-comment">         一共有count个数，会有f[count]种排序，但里面会有重复的排列</span><span class="hljs-comment">         需要把结果除以每个c[i]的阶乘来去重，这一步temp预处理了</span><span class="hljs-comment">         */</span>        <span class="hljs-built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans2 / temp &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算数基本定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的直径</title>
    <link href="/2020/10/03/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2020/10/03/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p>给定一棵树，树中包含 $n$ 个结点（编号$1\sim n$）和 $n−1$ 条无向边，每条边都有一个权值。</p><p>现在请你找到树中的一条最长路径。</p><p>换句话说，要找到一条路径，使得使得路径两端的点的距离最远。</p><p>注意：路径中可以只包含一个点。</p><p><strong>输入格式</strong></p><p>第一行包含整数 $n$。</p><p>接下来 $n−1$ 行，每行包含三个整数 $a_i,b_i,c_i$，表示点 $a_i$ 和 $b_i$ 之间存在一条权值为 $c_i$ 的边。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示树的最长路径的长度。</p><p><strong>数据范围</strong></p><p>$1≤n≤10000$,<br>$1≤a_i,b_i≤n$,<br>$−10^5≤ci≤10^5$</p><p><strong>输入样例：</strong></p><pre><code class="hljs basic"><span class="hljs-number">6</span><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">6</span><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-symbol">6 </span><span class="hljs-number">3</span> <span class="hljs-number">9</span><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">8</span><span class="hljs-symbol">6 </span><span class="hljs-number">1</span> <span class="hljs-number">7</span></code></pre><p><strong>输出样例：</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">22</span></code></pre><pre><code class="hljs c++"><span class="hljs-comment">// 树的直径：每个点取经过它的最长和次长距离，相加后最大的就是树的直径</span><span class="hljs-comment">// 这里采用的是树形dp做法</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10010</span>, M = N * <span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> h[N], e[M], w[M], ne[M], idx;<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;&#125;<span class="hljs-comment">// 这里还传了父节点，可以保证只会往下搜索</span><span class="hljs-comment">// 返回值：以u为根节点往下搜索的最长距离</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> father)</span> </span>&#123;    <span class="hljs-keyword">int</span> dist = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前点往下走的最长距离</span>    <span class="hljs-keyword">int</span> d1 = <span class="hljs-number">0</span>, d2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// d1:最长距离，d2:次长距离</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;        <span class="hljs-keyword">int</span> j = e[i];        <span class="hljs-keyword">if</span> (j == father) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 保证只往下搜索</span>                <span class="hljs-keyword">int</span> d = dfs(j, u) + w[i];        dist = max(dist, d);                <span class="hljs-comment">// 这里之所以不用dist来更新，而是用d，是因为dist到达的终点不一定是子节点j到达的终点</span>        <span class="hljs-comment">// d1和d2求的是经过u的距离</span>        <span class="hljs-keyword">if</span> (d &gt; d1) d2 = d1, d1 = d;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d &gt; d2) d2 = d;    &#125;        ans = max(ans, d1 + d2);        <span class="hljs-keyword">return</span> dist;    &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++) &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        add(a, b, c), add(b, a, c);    &#125;        <span class="hljs-comment">// 树是联通的，所以任取一点开始搜索</span>    dfs(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树形dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2020/09/25/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2020/09/25/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="组合数（求-C-a-b-模上p的值）"><a href="#组合数（求-C-a-b-模上p的值）" class="headerlink" title="组合数（求$C_a^b$模上p的值）"></a>组合数（求$C_a^b$模上p的值）</h2><p>根据数据范围来选择</p><p>$C_a^b$ 看a和b的范围</p><h3 id="a-b-le-2000"><a href="#a-b-le-2000" class="headerlink" title="a, b $\le$ 2000"></a>a, b $\le$ 2000</h3><p>$C_a^b = C_{a-1}^b + C_{a-1}^{b-1}$ 可以<strong>通过递推来计算</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> c[N][N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++)            <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    init();        <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">while</span> (n --) &#123;        <span class="hljs-keyword">int</span> a, b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c[a][b]);    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="a-b-le-10-5"><a href="#a-b-le-10-5" class="headerlink" title="a, b $\le$  $10^{5}$"></a>a, b $\le$  $10^{5}$</h3><p>预处理$\frac{a!}{(a-b)!b!}$中的阶乘</p><p>除数的取余需要用到逆元，<strong>预处理</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> fact[N], infact[N]; <span class="hljs-comment">// infact表示逆元</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> mod)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % mod;    <span class="hljs-keyword">while</span> (k) &#123;        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % mod;        a = (LL)a * a % mod;        k &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i ++ ) &#123;        fact[i] = (LL)fact[i - <span class="hljs-number">1</span>] * i % mod;        infact[i] = (LL)infact[i - <span class="hljs-number">1</span>] * qmi(i, mod - <span class="hljs-number">2</span>, mod) % mod;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    init();        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">while</span> (n --) &#123;        <span class="hljs-keyword">int</span> a, b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (LL)fact[a] * infact[b] % mod * infact[a - b] % mod);    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="a-b-le-10-18"><a href="#a-b-le-10-18" class="headerlink" title="a, b $\le$ $10^{18}$"></a>a, b $\le$ $10^{18}$</h3><p>mod上p的值，p是质数</p><p>数据量大，使用卢卡斯定理：$C_a^b\equiv C_{a, mod, p}^{b,mod,p} * C_{a/p}^{b/p},(mod,p)$</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-keyword">int</span> n, p;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p;    <span class="hljs-keyword">while</span> (k) &#123;        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = a; i &lt;= b; i ++, j --) &#123;        res = (LL)res * j % p;        res = (LL)res * qmi(i, p - <span class="hljs-number">2</span>) % p;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(LL a, LL b)</span> </span>&#123;    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> C(a, b);    <span class="hljs-keyword">return</span> (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">while</span> (n --) &#123;        LL a, b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;p);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, lucas(a, b));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>答案不取模时使用高精度</p><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>$C_{2n}^n - C_{2n}^{n-1} = C_{2n}^n / (n + 1)$</p><p>给定n个0和n个1，它们将按照某种顺序排成长度为2n的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中0的个数都不少于1的个数的序列有多少个。</p><p>输出的答案对$10^{9}+7$取模。</p><p><strong>输出格式</strong></p><p>共一行，包含整数n。</p><p><strong>输出格式</strong></p><p>共一行，包含一个整数，表示答案。</p><p><strong>数据范围</strong></p><p>$1≤n≤10^{5}$</p><p><strong>输入样例：</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">3</span></code></pre><p><strong>输出样例：</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">5</span></code></pre><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>, N = <span class="hljs-number">200010</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p;    <span class="hljs-keyword">while</span> (k) &#123;        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n; i &gt; n; i --) res = (LL)res * i % mod;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) res = (LL)res * qmi(i, mod - <span class="hljs-number">2</span>, mod) % mod;        res = (LL)res * qmi(n + <span class="hljs-number">1</span>, mod - <span class="hljs-number">2</span>, mod) % mod;        <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
